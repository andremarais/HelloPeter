alpha = .8,
lty = "solid")+
geom_line(data = combined, aes(x = date, y = bench), lwd= 1, lty = "dotted" )+
xlab("Red: Observed | Blue: Forecasted")+
ggtitle(paste("Account no: ",acc.numbers[i] , sep = ""))+
theme(axis.title.y = element_blank())+
annotate("text", x = min(combined$date), y = bench, label = "Benchmark", fontface = "bold", hjust = 0, fill = "black")+
annotate("text", x = min(combined$date), y = as.numeric(quantile(combined$value, 0.9)), label = "90% percentile", fontface = "bold",hjust = 0)
write.csv(eor, "eor.csv")
write.csv(benchmark, "bench.csv")
write.csv(benchmarks, "bench.csv")
tl <- list.files(file.path(getwd(), "/data"))
tl <- tl[order(tl)]
tl <- tl[length(tl)]
setwd("C:/Worksies/EOR/Davide/shiny")
tl <- list.files(file.path(getwd(), "/data"))
tl <- tl[order(tl)]
tl <- tl[length(tl)]
substring(tl, 5,14)
if (Sys.Date() != substring(tl, 5,14)) 1 else 2
require(RODBC)
require(ggplot2)
require(forecast)
require(zoo)
retail <- odbcConnect("Retail")
eor <- sqlQuery(retail, "Select * from MOMSYS02.MOMSYS02.INLIB.FINMOSC1PF where MSDATE > '20140701'", as.is = T)
head(eor)
eor$MSDATE <- as.Date(eor$MSDATE, format = "%Y%m%d")
head(eor)
eor$MSCOUNT <- as.numeric(eor$MSCOUNT)
benchmarks <- sqlQuery(retail, "Select MSBANO, max(MSBENCH) as MSBENCH from MOMSYS02.MOMSYS02.INLIB.FINMOSC3PF group by MSBANO", as.is = T)
benchmarks$MSBENCH <- as.numeric(benchmarks$MSBENCH)
head(read.csv(file.path(getwd(), "data", tl)))
shiny::runApp()
shiny::runApp()
head(eor, 100)
eor <- read.csv(file.path(getwd(), "data", tl))
tl <- list.files(file.path(getwd(), "/data"))
tl <- tl[order(tl)]
tl <- tl[length(tl)]
eor <- read.csv(file.path(getwd(), "data", tl))
head(eor, 100)
unique(eor$)
unique(eor$MSSYSUSER)
unique(eor$MSUSER)
as.character(unique(eor$MSUSER))
head(eor)
shiny::runApp()
aggregate(data=eor, MSDATE ~ MSTYPE + MSCOUNT)
head(eor)
aggregate(data = eor, MSCOUNT ~ MSDATE + MSTYPE)
aggregate(data = eor, MSCOUNT ~ MSDATE + MSTYPE, 'sum')
eor.agg <- aggregate(data = eor, MSCOUNT ~ MSDATE + MSTYPE, 'sum')
unique(eor.agg$MSTYPE)
as.character(unique(eor.agg$MSTYPE))
eor.new <- eor.agg[which(eor.agg$MSTYPE == "NEW  ")]
eor.alloc <- eor.agg[which(eor.agg$MSTYPE == "ALLOC")]
eor.new <- eor.agg[which(eor.agg$MSTYPE == "NEW  "),]
eor.alloc <- eor.agg[which(eor.agg$MSTYPE == "ALLOC"),]
merge(eor.new, eor.alloc, by.x = "MSDATE", by.y = "MSDATE")
eor.merge <- merge(eor.new, eor.alloc, by.x = "MSDATE", by.y = "MSDATE")
colnames(eor.merge)
eor.merge$MSTYPE.x <- NULL
eor.merge$MSTYPE.y <- NULL
colnames(eor.merge)
colnames(eor.merge) <- c("MSDATE", "NEW", "ALLOCATED")
eor.merge
head(eor.merge)
eor.merge$res <- eor.merge$NEW - eor.merge$ALLOCATED
plot(eor.merge$res)
eor.merge
shiny::runApp()
eor
order(eor$MSDATE, descending = T)
order(eor$MSDATE, desc = T)
?order
order(eor$MSDATE, decreasing = T)
eor[order(eor$MSDATE, desc = T),]
eor[order(eor$MSDATE, decreasing = F),]
head(eor[order(eor$MSDATE, decreasing = T),])
acc <- unique(eor$MSBANO)
metric <- "CLOSED"
date.range <- "2015-04-01"
forecast.range <- 30
status <- eor[which(eor$MSBANO %in% acc & as.Date(eor$MSDATE) >= date.range),]
status
status <- aggregate(MSCOUNT ~ MSDATE + MSTYPE, data = status, FUN = sum)
new.existing <- status$MSCOUNT[which(status$MSTYPE == metric)]
dates <- status$MSDATE[which(status$MSTYPE == metric)]
new.ts <- ts(data = new.existing)
fit=Arima(new.ts, seasonal=list(order=c(0,1,0),period=90),include.drift=T)
date.range
as.Date(date.range)
as.Date(date.range) - Sys.Date()
Sys.Date() - as.Date(date.range)
as.numeric(Sys.Date() - as.Date(date.range) )
min(as.numeric(Sys.Date() - as.Date(date.range) ), 90)
shiny::runApp()
date.range
status <- eor[which(eor$MSBANO %in% acc & as.Date(eor$MSDATE) >= date.range),]
status <- aggregate(MSCOUNT ~ MSDATE + MSTYPE, data = status, FUN = sum)
new.existing <- status$MSCOUNT[which(status$MSTYPE == metric)]
dates <- status$MSDATE[which(status$MSTYPE == metric)]
new.ts <- ts(data = new.existing)
fit=Arima(new.ts,
new.existing
new.existing
status <- eor[which(eor$MSBANO %in% acc & as.Date(eor$MSDATE) >= date.range),]
status
status <- aggregate(MSCOUNT ~ MSDATE + MSTYPE, data = status, FUN = sum)
status
new.existing <- status$MSCOUNT[which(status$MSTYPE == metric)]
new.existing
metric
unique(status$MSTYPE)
which(status$MSTYPE == metric)
status$MSTYPE
metric
metric <- "CLOSE"
new.existing <- status$MSCOUNT[which(status$MSTYPE == metric)]
dates <- status$MSDATE[which(status$MSTYPE == metric)]
new.existing
dates <- status$MSDATE[which(status$MSTYPE == metric)]
new.ts <- ts(data = new.existing)
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range)), 90)),
include.drift=T)
ts.fc <- forecast(fit, h = forecast.range)
new.ts
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range)), 90)),
include.drift=T)
new.ts
period= min(as.numeric(Sys.Date() - as.Date(date.range)), 90)
min(as.numeric(Sys.Date() - as.Date(date.range)), 90)
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period=33),
include.drift=T)
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90)),
include.drift=T)
ts.fc <- forecast(fit, h = forecast.range)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
date.range
date.range <- "2015-03-09"
status <- eor[which(eor$MSBANO %in% acc & as.Date(eor$MSDATE) >= date.range),]
status
status <- aggregate(MSCOUNT ~ MSDATE + MSTYPE, data = status, FUN = sum)
status
new.existing <- status$MSCOUNT[which(status$MSTYPE == metric)]
new.existing
dates <- status$MSDATE[which(status$MSTYPE == metric)]
dates
new.ts <- ts(data = new.existing)
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90)),
include.drift=T)
ts.fc <- forecast(fit, h = forecast.range)
combined <- data.frame(type = c(rep("observed", length(ts.fc[[7]])), rep("forecast", length(ts.fc[[4]]))) , value = c(ts.fc[[7]], ts.fc[[4]]))
new.dates <- as.Date(dates)
for ( i in (length(dates)+ 1):nrow(combined) ) {
new.dates[i] <- new.dates[i-1] + if(weekdays(new.dates[i-1]) == "Friday")  3 else 1
}
combined$date <- new.dates
ggplot() +
geom_rect(data = combined,
xmin = -Inf,
xmax = Inf,
ymin =  as.numeric(quantile(combined$value, 0.9)),
ymax = Inf,
fill = "#dc291e",
alpha = .005,
inherit.aes= F)+
geom_line(data = combined[combined$type == "observed",],
aes(x = date, y = value),
lwd= 1,
col = "#cd291e",
alpha = .8,
lty = "solid")+
geom_line(data = combined[combined$type == "forecast",],
aes(x = date, y = value),
lwd= 1,
col = "#003366",
alpha = .8,
lty = "solid")+
#geom_line(data = combined, aes(x = date, y = bench), lwd= 1, lty = "dotted" )+
xlab("Red: Observed | Blue: Forecasted")+
ggtitle(metric)+
theme(axis.title.y = element_blank())+
#annotate("text", x = min(combined$date), y = bench, label = "Benchmark", fontface = "bold", hjust = 0)+
annotate("text", x = min(combined$date), y = as.numeric(quantile(combined$value, 0.9)), label = "90% percentile", fontface = "bold",hjust = 0)
shiny::runApp()
metric <- "ALLOCATED"
metric <- "ALLOC"
status <- eor[which(eor$MSBANO %in% acc & as.Date(eor$MSDATE) >= date.range),]
status
status <- aggregate(MSCOUNT ~ MSDATE + MSTYPE, data = status, FUN = sum)
status
new.existing <- status$MSCOUNT[which(status$MSTYPE == metric)]
new.existing
dates <- status$MSDATE[which(status$MSTYPE == metric)]
new.ts <- ts(data = new.existing)
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90)),
include.drift=T)
new.ts
dates
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90))
)
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90)),
include.drift=T)
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90)))
shiny::runApp()
metric <- "NEW  "
status <- eor[which(eor$MSBANO %in% acc & as.Date(eor$MSDATE) >= date.range),]
status <- aggregate(MSCOUNT ~ MSDATE + MSTYPE, data = status, FUN = sum)
new.existing <- status$MSCOUNT[which(status$MSTYPE == metric)]
new.existing
dates <- status$MSDATE[which(status$MSTYPE == metric)]
new.ts <- ts(data = new.existing)
new.ts
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90)))
dates
min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90))
min(as.numeric(Sys.Date() - as.Date(date.range) -1), 90)
length(ts)
length(new.ts)
dates
length(dates)
shiny::runApp()
shiny::runApp()
setwd("C:/Users/anmarais/Desktop/GitHub/HelloPeter")
mom <- readRDS("Momentum.rds")
mom
hp[1] <- httpGET("http://hellopeter.com/momentum-health/compliments-and-complaints?country=South%20Africa&pg=1")
require(RCurl)
require(XML)
require(wordcloud)
hp[1] <- httpGET("http://hellopeter.com/momentum-health/compliments-and-complaints?country=South%20Africa&pg=1")
hp <- c()
link <- data.frame()
title <- data.frame()
time <- data.frame()
type <- data.frame()
postbody <- data.frame()
hp[1] <- httpGET("http://hellopeter.com/momentum-health/compliments-and-complaints?country=South%20Africa&pg=1")
#gets last page
lpsnippet <- substring(hp[1], gregexpr(">>", hp[1])[[1]][1], gregexpr(">>", hp[1])[[1]][2])
a <- as.numeric(regexpr("pg=",lpsnippet)[[1]] + attr(gregexpr("pg=",lpsnippet)[[1]], "match.length"))
b <- min(gregexpr("\"",lpsnippet)[[1]][which(gregexpr("\"",lpsnippet)[[1]] > gregexpr("pg=",lpsnippet)[[1]][1])]) -1
pages <- as.numeric(substring(lpsnippet, a, b))
for (i in 1:2){
hp[i] <- httpGET(paste("http://hellopeter.com/momentum-health/compliments-and-complaints?country=South%20Africa&pg=", i, sep = ""))
print(i)
}
# Run this
for (i in 1:2) {
linklocations <- gregexpr("<div class=\"td-item2\"><a class=\"fb-link\"", hp[i])
for (j in 1:length(linklocations[[1]])) {
#gets URL
snippet <- substring(hp[i],
linklocations[[1]][j],
if (j == length(linklocations[[1]])) nchar(hp[i]) else linklocations[[1]][j+1])
# Link
link[j,i] <- substring(snippet, gregexpr("href=\"",snippet)[[1]][1] + 6,gregexpr(" title=\"",snippet)[[1]][1]-2)
# Title
a <- gregexpr("title=\"",snippet)[[1]][1] + 7
b <- min(gregexpr("\">",snippet)[[1]][which(gregexpr("\">",snippet)[[1]] > gregexpr("title=\"",snippet)[[1]][1] + 7)])-1
title[j,i] <- substring(snippet, a, b)
# Time of post
a <- gregexpr("\">\t",snippet)[[1]][1] + 7
b <- min(gregexpr("\t",snippet)[[1]][which(gregexpr("\t",snippet)[[1]] > gregexpr("\">\t",snippet)[[1]][1] + 7)])-1
time[j,i] <- as.character(as.Date(trim.leading(substring(snippet, a, b)), format = "%H:%M:%S %A %d %b %y"))
# Type of post
if (regexpr("complaints/", link[j,i], ignore.case = T) != -1) type[j,i] <- "Complaint"
if (regexpr("complaints-to-compliments/", link[j,i], ignore.case = T) != -1) type[j,i] <- "Convertion"
if (regexpr("compliments/", link[j,i], ignore.case = T) != -1) type[j,i] <- "Compliment"
# Downloads post
if (!is.na(link[j,i])) {
post <- httpGET(link[j,i])
a <- gregexpr("shade border justify\">", post)
b <- gregexpr("<div class=\"report-action\">", post)
postbody[j,i] <- cleanFun(substring(post, a[[1]][1] + attr(a[[1]], "match.length"), b[[1]][1]-1))
}
#remove name changes strings
if (gregexpr(txt, postbody[j,i]) != -1) {
to.remove <- substring(postbody[j,i],
gregexpr(txt,postbody[j,i])[[1]][1],
gregexpr(txt,postbody[j,i])[[1]][1] + attr(gregexpr(txt,postbody[j,i])[[1]], "match.length") -1)
postbody[j,i] <- gsub(to.remove, "", postbody[j,i])
postbody[j,i] <- gsub("\t", "",gsub("\n", "", postbody[j,i]))
}
print(c(i,j))
}
}
trim.leading <- function (x)  sub("^\\s+", "", x)
trim.trailing <- function (x) sub("\\s+$", "", x)
# Run this
for (i in 1:2) {
linklocations <- gregexpr("<div class=\"td-item2\"><a class=\"fb-link\"", hp[i])
for (j in 1:length(linklocations[[1]])) {
#gets URL
snippet <- substring(hp[i],
linklocations[[1]][j],
if (j == length(linklocations[[1]])) nchar(hp[i]) else linklocations[[1]][j+1])
# Link
link[j,i] <- substring(snippet, gregexpr("href=\"",snippet)[[1]][1] + 6,gregexpr(" title=\"",snippet)[[1]][1]-2)
# Title
a <- gregexpr("title=\"",snippet)[[1]][1] + 7
b <- min(gregexpr("\">",snippet)[[1]][which(gregexpr("\">",snippet)[[1]] > gregexpr("title=\"",snippet)[[1]][1] + 7)])-1
title[j,i] <- substring(snippet, a, b)
# Time of post
a <- gregexpr("\">\t",snippet)[[1]][1] + 7
b <- min(gregexpr("\t",snippet)[[1]][which(gregexpr("\t",snippet)[[1]] > gregexpr("\">\t",snippet)[[1]][1] + 7)])-1
time[j,i] <- as.character(as.Date(trim.leading(substring(snippet, a, b)), format = "%H:%M:%S %A %d %b %y"))
# Type of post
if (regexpr("complaints/", link[j,i], ignore.case = T) != -1) type[j,i] <- "Complaint"
if (regexpr("complaints-to-compliments/", link[j,i], ignore.case = T) != -1) type[j,i] <- "Convertion"
if (regexpr("compliments/", link[j,i], ignore.case = T) != -1) type[j,i] <- "Compliment"
# Downloads post
if (!is.na(link[j,i])) {
post <- httpGET(link[j,i])
a <- gregexpr("shade border justify\">", post)
b <- gregexpr("<div class=\"report-action\">", post)
postbody[j,i] <- cleanFun(substring(post, a[[1]][1] + attr(a[[1]], "match.length"), b[[1]][1]-1))
}
#remove name changes strings
if (gregexpr(txt, postbody[j,i]) != -1) {
to.remove <- substring(postbody[j,i],
gregexpr(txt,postbody[j,i])[[1]][1],
gregexpr(txt,postbody[j,i])[[1]][1] + attr(gregexpr(txt,postbody[j,i])[[1]], "match.length") -1)
postbody[j,i] <- gsub(to.remove, "", postbody[j,i])
postbody[j,i] <- gsub("\t", "",gsub("\n", "", postbody[j,i]))
}
print(c(i,j))
}
}
cleanFun <- function(htmlString) {
return(gsub("<.*?>", "", htmlString))
}
post <- httpGET(link[j,i])
post <- httpGET(link[j,i])
link[j,i]
post <- httpGET(link[j,i])
post
post <- httpGET(link[j,i])
post
gregexpr("SUPPLIER'S RESPONSE", post)
substring(popst, 15206, 15806)
substring(post, 15206, 15806)
min(gregexpr("SUPPLIER'S RESPONSE", post))
min(gregexpr("SUPPLIER'S RESPONSE", post)[[1]])
a <- min(gregexpr("SUPPLIER'S RESPONSE", post)[[1]])
gregexpr("[0-9]{2}:[0-9]{2}:[0-9]{2}", substring(post, a, a + 1000))
b <- min(gregexpr("[0-9]{2}:[0-9]{2}:[0-9]{2}", substring(post, a, a + 1000))[[1]])
gregexpr("</td>", substring(post, b, b + 60)))
gregexpr("</td>", substring(post, b, b + 60))
gregexpr("</td>", substring(post, a + b, a + b + 60))
c <- gregexpr("</td>", substring(post, a + b, a + b + 60))
substring(post, b, b + c)
c <- min(gregexpr("</td>", substring(post, a + b, a + b + 60))[[1]])
substring(post, b, b + c)
substring(post, a + b, a +  b + c)
c <- min(gregexpr("</td>", substring(post, a + b + 10, a + b + 60))[[1]])
substring(post, a + b, a +  b + c)
substring(post, a + b + 10, a +  b + c)
substring(post, a + b + 10, a +  b + c + 10)
substring(post, a + b + 10, a +  b + c + 8)
d <- substring(post, a + b + 10, a +  b + c + 8)
d
as.Date(as.character(d), format = "%a %d %b %y"
)
a <- min(gregexpr("SUPPLIER'S RESPONSE", post)[[1]])
b <- min(gregexpr("[0-9]{2}:[0-9]{2}:[0-9]{2}", substring(post, a, a + 100))[[1]])
c <- min(gregexpr("</td>", substring(post, a + b , a + b + 60))[[1]])
d <- substring(post, a + b + 10, a +  b + c + 8)
d
a <- min(gregexpr("SUPPLIER'S RESPONSE", post)[[1]])
b <- min(gregexpr("[0-9]{2}:[0-9]{2}:[0-9]{2}", substring(post, a, a + 1000))[[1]])
c <- min(gregexpr("</td>", substring(post, a + b , a + b + 60))[[1]])
d <- substring(post, a + b + 10, a +  b + c + 8)
d
b <- min(gregexpr("[0-9]{2}:[0-9]{2}:[0-9]{2}", substring(post, a, a + 500))[[1]])
c <- min(gregexpr("</td>", substring(post, a + b , a + b + 60))[[1]])
d <- substring(post, a + b + 10, a +  b + c + 8)
d
a <- "a"
min(gregexpr("SUPPLIER'S RESPONSE", post)[[1]])
min(gregexpr("SUPPLIER'S RESPONSE", a)[[1]])
shiny::runApp('C:/Worksies/EOR/Davide/shiny')
status <- eor[which(eor$MSBANO %in% acc & as.Date(eor$MSDATE) >= date.range),]
status <- aggregate(MSCOUNT ~ MSDATE + MSTYPE, data = status, FUN = sum)
new.existing <- status$MSCOUNT[which(status$MSTYPE == metric)]
dates <- status$MSDATE[which(status$MSTYPE == metric)]
new.ts <- ts(data = new.existing)
fit=Arima(new.ts,
seasonal=list(order=c(0,1,0),period= min(length(new.ts) -1, 90)))
ts.fc <- forecast(fit, h = forecast.range)
combined <- data.frame(type = c(rep("observed", length(ts.fc[[7]])), rep("forecast", length(ts.fc[[4]]))) , value = c(ts.fc[[7]], ts.fc[[4]]))
new.dates <- as.Date(dates)
for ( i in (length(dates)+ 1):nrow(combined) ) {
new.dates[i] <- new.dates[i-1] + if(weekdays(new.dates[i-1]) == "Friday")  3 else 1
}
combined$date <- new.dates
combined
c.ts <- ts(data = combined)
decompose(c.ts)
c.ts
c.ts <- ts(data = combined$value)
decompose(c.ts)
c.ts
length(combined$value)
c.ts <- ts(data = combined$value, frequency = length(combined$value) )
decompose(c.ts)
c.ts <- ts(data = combined$value, frequency = 5)
decompose(c.ts)
c.ts <- ts(data = combined$value, frequency = 1)
decompose(c.ts)
length(combined$value)
c.ts <- ts(data = combined$value, frequency = 85)
decompose(c.ts)
c.ts <- ts(data = combined$value, frequency = 7)
plot(decompose(c.ts))
decompose(ts(data = combined$value, frequency = 7))
decompose(ts(data = combined$value, frequency = 5))
plot(decompose(ts(data = combined$value, frequency = 5)))
plot(decompose(ts(data = combined$value, frequency = 7)))
plot(decompose(ts(data = combined$value, frequency = 30)))
plot(decompose(ts(data = combined$value, frequency = 1)))
plot(decompose(ts(data = combined$value, frequency = 90)))
plot(decompose(ts(data = combined$value, frequency = 30)))
plot(combined$value)
plot(combined$value, type = "l")
shiny::runApp('C:/Worksies/EOR/Davide/shiny')
shiny::runApp('C:/Worksies/EOR/Davide/shiny')
str(combined$value)
ggplot() +
geom_rect(data = combined,
xmin = -Inf,
xmax = Inf,
ymin =  as.numeric(quantile(combined$value, 0.9)),
ymax = Inf,
fill = "#dc291e",
alpha = .005,
inherit.aes= F)+
geom_line(data = combined[combined$type == "observed",],
aes(x = date, y = value),
lwd= 1,
col = "#cd291e",
alpha = .8,
lty = "solid")+
geom_line(data = combined[combined$type == "forecast",],
aes(x = date, y = value),
lwd= 1,
col = "#003366",
alpha = .8,
lty = "solid")
shiny::runApp('C:/Worksies/EOR/Davide/shiny')
shiny::runApp('C:/Worksies/EOR/Davide/shiny')
shiny::runApp('C:/Worksies/EOR/Davide/shiny')
shiny::runApp('C:/Worksies/EOR/Davide/shiny')
require(shiny)
shiny::runApp('C:/Users/anmarais/Desktop/GitHub/ClientDashboard')
setwd("C:/Users/anmarais/Desktop/GitHub/HelloPeter")
hp.df <- readRDS("hellopeterdf.RDS")
hp.df
ggplot()+
geom_bar(data = hp.monthly, aes(x = post.date.month, y = freq, fill = type), stat = "identity", position = "dodge")+
scale_fill_brewer(palette = "Set1")
hp.monthly <- count(hp.df, c('post.date.month','type'))
hp.count <- count(hp.df, c('post.date', 'type'))
ggplot()+
geom_bar(data = hp.monthly, aes(x = post.date.month, y = freq, fill = type), stat = "identity", position = "dodge")+
scale_fill_brewer(palette = "Set1")
hp.monthly <- count(hp.df, c('post.date.month','type'))
require(plyr)
hp.monthly <- count(hp.df, c('post.date.month','type'))
hp.count <- count(hp.df, c('post.date', 'type'))
ggplot()+
geom_bar(data = hp.monthly, aes(x = post.date.month, y = freq, fill = type), stat = "identity", position = "dodge")+
scale_fill_brewer(palette = "Set1")
ggplot() +
geom_bar(data = ave.time.pm, aes(x = post.date.month, y = as.numeric(response.time), fill = as.numeric(response.time)), stat = "identity")
str(hp.df)
ave.time.pm <- aggregate(data = hp.df, response.time ~ post.date.month, FUN = mean)
head(ave.time.pm)
ggplot() +
geom_bar(data = ave.time.pm, aes(x = post.date.month, y = as.numeric(response.time), fill = as.numeric(response.time)), stat = "identity")
hp[1] <- httpGET(paste(MomHealth, 1), sep = "")
MomHealth <- "http://hellopeter.com/momentum-health/compliments-and-complaints?country=South%20Africa&pg="
Momentum <- "http://hellopeter.com/momentum/compliments-and-complaints?country=South%20Africa&pg="
MSTI <- "http://hellopeter.com/momentum-short-term-insurance/compliments-and-complaints?country=South%20Africa&pg="
MomRA <- "http://hellopeter.com/metropolitan-retirement-administrators/compliments-and-complaints"
hp[1] <- httpGET(paste(MomHealth, 1), sep = "")
paste(MomHealth, 1), sep = "")
paste(MomHealth, 1, sep = "")
substring(hp[1], gregexpr(">>", hp[1])[[1]][1], gregexpr(">>", hp[1])[[1]][2])
MomRA <- "http://hellopeter.com/metropolitan-retirement-administrators/compliments-and-complaints"
hp[1] <- httpGET(paste(MomRA, 1, sep = ""))
lpsnippet <- substring(hp[1], gregexpr(">>", hp[1])[[1]][1], gregexpr(">>", hp[1])[[1]][2])
lpsnippet
is.na(lpsnippet)
BU <- MomRA
hp[1] <- httpGET(paste(MomRA, 1, sep = ""))
cat(hp[1])
